(ns power-series.core)

(def ones (repeat 1))
(def ints (drop 1 (range)))

(defn add-series [s1 s2]
  (map + s1 s2))
;; (defn add-series [s1 s2]
;;   (transduce (map +) cons s1 s2))

(defn sub-series [s1 s2]
  (map - s1 s2))
;; (defn sub-series [s1 s2]
;;   (transduce (map -) cons s1 s2))

(defn scale-series [s x]
  (map #(* x %1) s))
;; (defn scale-series [s1 s2]
;;   (transduce (map #(* %1 x)) cons s))

(defn negate-series [s]
  (scale-series s -1))

(defn mul-series [s1 s2] 
   (cons (* (first s1)
            (first s2))
         (lazy-seq (add-series (scale-series (rest s2) (first s1))
                               (mul-series (rest s1) s2)))))
           
;; (defn partial-sums [s]
;;   (if (nil? s)
;;       '()
;;       (cons (first s)
;;             (lazy-seq (add-series (next s)
;;                         (partial-sums s))))))
;; (defn mul-series [s1 s2]
;;   (partial-sums (map * s1 s2)))

(defn invert-series [s]
   (cons 1
        (lazy-seq (negate-series
                   (mul-series (next s)
                               (invert-series s))))))

(defn div-series [s1 s2]
  (if (zero? (first s2))
    (println "ERROR: denominator has a zero constant term")
    (scale-series (mul-series s1
                              (invert-series (scale-series s2 (/ 1 (first s2)))))
                  (/ 1 (first s2)))))
           
(defn differentiate-series [s]
  (map * s ints))
;; (defn differentiate-series [s]
;;   (transduce (map * ints) cons s))
  
;; (defn integrate-series [s]
;;   (map * (map / ones ints) s))
;; (defn integrate-series [s]
;;   (transduce (map * (map / ones ints)) cons s))

(defn integrate-series [s]
  (map / s ints))
;; (defn integrate-series [s]
;;   (transduce (map / s ints) cons s1 s2))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;integral test
(defn sine-series []
  (sequence
   (comp
    (filter odd?)
    (integrate-series ints))))
(defn cosine-series []
  (sequence
   (comp
    (filter even?)
    (integrate-series ints))))

(take 10 (sequence (comp (filter even?) (map /)) ints))

;derivative test
;; (declare cosine-series)
;; (defn sine-series []
;;   (differentiate-series
;;    (negate-series
;;     (repeatedly #(cosine-series)))))
;; (defn cosine-series []
;;   (differentiate-series
;;    (repeatedly #(sine-series))))

(defn -main []
  "test: should be equal to 1"
  (add-series
   (mul-series sine-series sine-series)
   (mul-series cosine-series cosine-series)))

;; (defn -main []
;;   (print
;;    (take 10 (sine-series))))

(defn tangent-series [n]
   (take n
         (div-series sine-series cosine-series)))

(defn exp-series []
  (map #(Math/pow Math/E %1) ints))

(defn exp-test []
    (let [exp-integ (take 10 (integrate-series (exp-series)))
          expt-deriv (take 10 (differentiate-series
                               (integrate-series (exp-series))))]
      (if (= exp-integ expt-deriv)
        true
        false)))

;add compose-series (chain-rule)
