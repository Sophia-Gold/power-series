{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf470
{\fonttbl\f0\fswiss\fcharset0 ArialMT;}
{\colortbl;\red255\green255\blue255;\red26\green26\blue26;\red255\green255\blue255;\red16\green60\blue192;
}
\margl1440\margr1440\vieww18040\viewh9740\viewkind0
\deftab720
\pard\pardeftab720\sl300\partightenfactor0

\f0\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 Good Afternoon,\cb1 \
\
\cb3 I\'92ve had a horribly busy week due to chronic illness-related medical bureaucracy (perhaps a story for another time...) and didn't want you to get the wrong idea: the truth is I'm not sure how this happened, but I see any code review or exercise given from you as a once in a lifetime opportunity and very much want to see this through as much as possible. So in that interest, I'm presenting a rough sketch of what I've been working on in lieu of the code I've yet to finish to my satisfaction.\'a0\cb1 \
\
\cb3 Composition and reversion were easier than anticipated once I let go of implementing formulae like Fa\'e0 di Bruno's\'a0(subscript, to adopt your term of derision) and simply trusted in recursion (e.g. how the recursive method for reversion remains unique in the literature for its computational simplicity). I also implemented coercion and eliminated a couple trivial operators. In that vein, I would eventually appreciate some input on what operators to include or exclude in the name of brevity. Euler and Walsh transforms come to mind, the former already implemented.\cb1 \
\
\cb3 Differences between Haskell and Lisp are notable, mainly operator overloading and type polymorphism in the former and more explicit recursion plus stronger support for concurrency (only specific to Clojure) in the latter. I'm by no means beholden to Lisp, and certainly not Clojure, but recognizing these distinctions led to a few design decisions. Namely, due to the nature of Lisp's tail-recursion, I reversed my decision to encapsulate constant terms in the operators as it became impossible to cons them on the arguments without the use of numerous inconsistent and crufty closures whereas I think I can maintain consistency in consing them on the series functions. In this sense, I do agree with Abelson and Sussman. Since you pointed this out to me, and I since I now can't help but notice it in the arguments of many of your operators, please feel free to correct me.\cb1 \
\
\cb3 On the other hand, an upside to this linguistic distinction is that Clojure combines a full CSP\'a0implementation with facilities for laziness (if you recall, the original impetus for my interest in porting the power series code after witnessing the strict and inefficient Go demo) so I went ahead and ported the series functions to this form. I'm still somewhat unsure as to whether I should also change the recursive operators to CSP, but leaning strongly towards no. My intention for doing so with the series functions lies in integrating the power series code with my numeric tower reference previously ({\field{\*\fldinst{HYPERLINK "https://github.com/Sophia-Gold/Symbolic-Algebra.clj"}}{\fldrslt \cf4 \ul \ulc4 \strokec4 https://github.com/Sophia-Gold/Symbolic-Algebra.clj}}) containing sparse polynomial term lists, which also comes with the advantage of complex numbers in both rectangular and polar form as well as my custom rational implementation that allows me to bypass Java's default overflow\'97\'a0which, correct me if I\'92m wrong, I now understand to be similar to your overriding of Haskell\'92s default rules for interpreting constants.\'a0\cb1 \
\
\cb3 I believe in lazy CSP lies the solution to your problem of matching sparse coefficients for bivariate computation by offering fine-grained control over the relative spacing of recursive loops prior to coercion (although I must admit I\'92m speculating a bit as I don\'92t often find a use for CSP and am only just getting up to speed with the implementation). If so, I would like to benchmark it against the existing symbolic algebra package for Clojure that makes use of Daniel Friedman's MiniKanren relational logic library to handle the multivariate situation as the lazy version will surely be magnitudes faster than bidirectional graph search. I often tend to get ahead of myself, but could I be correct in thinking this is an area of research where stream processing could potentially beat at least all common methods asymptotically in time?\cb1 \
\
\cb3 Regardless, in thinking about CSP for streams I went back and reread your Squint paper (as well as all your relevant papers\'97I actually originally missed 
\i Functional Pearls
\i0 , which would have been most helpful in explaining the syntax of the Haskell implementation\'97and am still getting to Karczmarczuk and Pavlovic & Escarcdo). Risking sounding melodramatic, I had this moment where the page with the diagram for the recursive Cauchy product was like how Alan Kay described viewing McCarthy's manual for LISP 1.0 as the laws of classical mechanics. Also, laziness as routing of concurrent channels by demand was incredibly prescient and still unrealized, so to speak. Given that we finally now have the linguistic conventions to change that, it couldn't help but get my wheels turning.\cb1 \
\
\cb3 But oddly enough in rereading 
\i Squint
\i0  two other things of coincidence or serendipity stood out I somehow missed when reading Landin on streams and Kahn/MacQueen respectively: first that the larger project I had been finishing that initially delayed me in getting back to you regarding this one involved an ad hoc threadsafe CPS implementation and I kept thinking about power series and debating making it lazy except that it necessitated centralized stack-based storage, and second that while working on power series I somehow thought I independently manifested the idea for infinite precision streaming integers and decimals whereas I suppose I missed the mention of it in the Coroutine paper all along.\cb1 \
\
\cb3 I'm very excited about all of the above and hope to show you some polished code soon. I also don't want to stop at power series. On the one hand, it's giving me a great avenue for\'a0learning more math I really desperately need to regardless. But on the other, I'm increasingly intrigued by applications of similar stream-based techniques to the even less familiar domain of systems programming. Since I've learned so much through\'a0chrestomathy, perhaps there's an application along those lines I could consider next?\
\cb1 \
\cb3 Hope you're well in this dreary weather.\
\
Sophia}